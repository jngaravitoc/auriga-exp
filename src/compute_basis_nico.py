"""
Script to compute an empirical basis in a cosmological halo using EXP
Code is ainly adopted from vaiours scripts provided by Mike Petersen

Authors: Silvio Verela, Nico Garavito Camargo

Jun 2022 - 

usage:


"""

import numpy as np
from numpy import Inf
import sys

##  exp
sys.path.append("/u/ngaravito/codes/exp/build/utils/Analysis/")
from spherical_basis_builder import *
import simpleSL
from exptool.basis import spheresl
from exptool.utils import halo_methods

## Auriga
import LibAu as la
 

def plot_basis(basis, nmax, figname, rmin=0, rmax=2.5, rbins=2000):
    xvals = 10.**(np.linspace(rmin, rmax, rbins))
    fig, ax = plt.subplots(1, 1)
    for n in range(0,nmax):
        ax.plot(xvals, basis[0][n], label='n={}'.format(n))
    ax.legend()
    ax.savefig(figname, bbox_inches='tight')
    fig.close()


def compute_density(coordinates, expcoef):
    # den0 is the monopole contribution to the density
    # den1 is the l>0 contribution to the densityx`
    # (therefore, the total density is den0+den1)
    # pot0 is the monopole contribution to the potential
    # pot1 is the l>0 contribution to the potential
    # potr is the radial force
    # pott is the polar force
    # potp is the azimutuhal force

    # specify your cache generated by simpleSL
    sph_file = './.slgrid_sph_cache'

    # specify your spherical model file (input to simpleSL)
    mod_file = './m12b_SPHLbasis_empirical.txt'

    # pull in the cache data
    lmax, nmax, numr, cmap, rmin, rmax, scale, ltable, evtable, eftable = halo_methods.read_cached_table(sph_file)
    xi, rarr, p0, d0 = halo_methods.init_table(mod_file, numr, rmin, rmax, cmap, scale)

    # specify the coefficient array: you will not have to do this, because you already have the coefficients in the correct format
    # from simpleSL.coefsl()
    #llmax = (lmax+1)*(lmax+1)
    #expcoef = np.zeros([llmax,nmax])

    # make some mock coefficient values
    #expcoef[0][0] = 6.0
    #expcoef[1][0] = 0.01

    # specify coordinate
    #r     = 0.01 # 3d radius
    #costh = 0.0  # = z/r, polar coordinate
    #phi   = 0.0  # azimuth
    r, costh, phi = coordinates[0], coordinates[1], coordinates[2]
    # evaluate fields at a specifc point
    den0,den1,pot0,pot1,potr,pott,potp = spheresl.all_eval(r, costh, phi, expcoef,xi,p0,d0,cmap,scale,lmax,nmax,evtable,eftable)
    return den0, den1




if __name__ == "__main__":
    nhalo=21 #Name Halo
    nsnap= 63 #z=0
    sim = la.Reader_Au(Nhalo=nhalo,Nsnap=nsnap) #Read Simulation
    header = sim.Header()
    h=header['hubbleparam']
    sc=header['time']

    Rvir =sim.sf.data['frc2'][0]*1000*sc/h

    fields_stars = ['pos','vel','id','mass','type','pot','age']
    Datstars = sim.Snapshot_Subhalo(idSubhalo=0,snapType='stars',fields=fields_stars)


    fields_dm = ['pos','vel','id','mass','type','pot']
    DatDM = sim.Snapshot_Subhalo(idSubhalo=0,snapType='dm1',fields=fields_dm)
    #Rotate Halo
    Data = {'stars':Datstars,'dm1':DatDM}
    param = {'spos':sim.sf.data['spos'][0,:],'svel':sim.sf.data['svel'][0,:],'header':sim.Header()}
    gal = la.ToolRot(Data=Data, param=param)
    Data = gal.Rotate()

    Datstars=Data['stars']
    DatDM = Data['dm1']

    
    #*************************  Compute BFE: *****************************
    
    # 1. Get positions from simulation 
    pos = DatDM['pos'] #part_rot[not_in_subs]
    mass = DatDM['mass']  #part['dark']['mass'][not_in_subs]
    #M_tot = np.sum(mass)

    #selecting 1million random particles
    ind = np.arange(0,len(mass),1,dtype=int)
    nparticles = 100000
    sel = np.random.choice(ind, nparticles, replace=False).astype(int)
    pos, mass = pos[sel],mass[sel]
    
    #print(np.shape(pos))
    # 2. Make a density profiles from the simulation data
    # TODO check this is the right way to compute the density profile!
    #rr = np.sqrt(pos[:,0]**2 + pos[:,1]**2 + pos[:,2]**2)
    #rbins, dreturn = return_density(np.log10(rr), 1., rangevals=[0., 2.5],bins=100)

    #plt.figure()
    #plt.plot(rbins, dreturn)
    #plt.yscale('log')
    #plt.savefig("halo_density.png", bbox_inches='tight')
    #plt.close()

    # 3. Build empirical basis
    #,D,M,P = makemodel_empirical(rbins, dreturn, pfile='m12b_SPHLbasis_empirical.txt')
    #TODO: what are 2, 6 args

    ebf = simpleSL.slfunctions('./m12b_SPHLbasis_empirical.txt',2,6,0.,2.5, 2000)
    #plot_basis(ebf, "auringa_halo_empirical_basis_trst.png")
    # -> Cache gets written here as: .slgrid_sph_cache
    
     #4. Compute the coefficients using the empirical basis function ebf
    coefficients = simpleSL.coefsl(mass, pos[:,0], pos[:,1], pos[:,2],  './m12b_SPHLbasis_empirical.txt',2,6)

    #print(np.shape(ebf))
    #print(ebf)

    # TODO
    # 5. Check orthogonality of the basis
    # 6. Plot density fields! 
    # 7. Check units!
    # 8. Make function to write coefficients. 

    print(np.shape(coefficients))
    
    r = np.linspace(0,200,50)
    theta = np.linspace(0,2*np.pi,50)
    rgrid, thetagrid = np.meshgrid(r, theta)
    phigrid = np.zeros_like(rgrid)

    den_mon = np.zeros_like(rgrid)
    den_nonmon = np.zeros_like(rgrid)

    for i in range(50):
        for j in range(50):
            den_mon[i][j], den_nonmon[i][j] = compute_density([rgrid[i][j], thetagrid[i][j], 0], coefficients)

    Xgrid = rgrid * np.cos(thetagrid)
    Ygrid = rgrid * np.sin(thetagrid)
    
    fig, ax = plt.subplots(1, 1)
    ax.imshow(np.log10(np.abs(den_mon + den_nonmon)), extent=[-400, 400, -400, 400])
    fig.savefig("2d_density.png", bbox_inches='tight')
    plt.close()
    

    


